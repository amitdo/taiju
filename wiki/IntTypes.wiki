#summary 基本型の説明．

== はじめに ==

libtaiju で使用する整数の型や定数などは，int-types.h で定義されています．

----

== 整数 ==

32-bit 環境と 64-bit 環境のいずれにおいても 64-bit 整数を用いるため，
`long` ではなく `long long` を用いています．
`long long` が 128-bit 整数と解釈される時代が来ると問題になりますが，
しばらく先になりそうなので大丈夫だと思います．
他に，`Int16` および `UInt16` は使っていないのでほとんど影響はありませんが，
環境によっては `int` を 32-bit 整数と仮定していることが問題になるかもしれません．

=== 符号あり整数 ===

{{{
typedef signed char Int8;
typedef signed short Int16;
typedef signed int Int32;
typedef signed long long Int64;
}}}

=== 符号なし整数 ===

{{{
typedef unsigned char UInt8;
typedef unsigned short UInt16;
typedef unsigned int UInt32;
typedef unsigned long long UInt64;
}}}

----

== 定数 ==

libtaiju を利用するときに使う可能性がある定数は，
`TrieType`, `IndexType`, `NodeOrder` の 3 つです．
ただし，IndexType はビットベクターを単体で
用いるとき以外には使いません．

=== トライの種類 ===

`TrieType` はトライの種類を表す型です．
`TrieConverterFactory::Create()` の引数として使うことで，
指定した種類のトライを構築できます．

{{{
enum TrieType
{
  PODS_TRIE,
  LOB_TRIE,
  LOUDS_TRIE,
  PLOUDS_TRIE,
  BP_TRIE,
  DFUDS_TRIE,
  DEFAULT_TRIE_TYPE = PODS_TRIE
};
}}}

各トライの概要はプロジェクト taiju のホームページにて確認できます．

 * プロジェクト taiju のホームページ
  * http://code.google.com/p/taiju/

=== ビットベクターの索引種別 ===

`BitVectorBuilder::Open()` に `WITH_SELECT_INDEX` を渡すことにより，
`ConstBitVector::select()` を高速化できます．

{{{
enum IndexType
{
  ONLY_RANK_INDEX,
  WITH_SELECT_INDEX,
  DEFAULT_INDEX_TYPE = ONLY_RANK_INDEX
};
}}}

 * `ONLY_RANK_INDEX`
  * `rank()` 用の索引のみを付加します．
  * `select()` も利用できますが，時間がかかります．
 * `WITH_SELECT_INDEX`
  * `rank()` 用の索引に加えて `select()` 用の索引を付加します．

=== ノードの配置順序 ===

トライを構築するとき，ノードの配置順序を操作します．
初期設定ではラベル昇順にノードを配置しますが，
出現頻度が高い順にノードを配置することができれば，
検索時間を大幅に短縮することが可能です．

トライの構築において，登録する文字列には個別に重みを指定できます．
デフォルトではすべての文字列に 1.0 を重みとして与えるため，
`TOTAL_WEIGHT_ORDER` を選択することにより，各文字列の出現頻度が同じと
仮定した場合における，出現頻度が高い順の配置順序になります．

{{{
enum NodeOrder
{
  ASCENDING_LABEL_ORDER,
  DESCENDING_LABEL_ORDER,
  TOTAL_WEIGHT_ORDER,
  MAX_WEIGHT_ORDER,
  RANDOM_ORDER,
  LABEL_ORDER = ASCENDING_LABEL_ORDER,
  DEFAULT_NODE_ORDER = LABEL_ORDER
};
}}}

 * `ASCENDING_LABEL_ORDER`
  * *ラベル昇順*にノードを配置します．
 * `DESCENDING_LABEL_ORDER`
  * *ラベル降順*にノードを配置します．
 * `TOTAL_WEIGHT_ORDER`
  * 各ノードから下方に辿って復元可能な文字列に付与されている*重みの合計が降順*になるようにノードを配置します．
 * `MAX_WEIGHT_ORDER`
  * 各ノードから下方に辿って復元可能な文字列に付与されている*重みの最大値が降順*になるようにノードを配置します．
 * `RANDOM_ORDER`
  * *ランダム順*にノードを配置します．
  * 並べ替えには，`std::random_shuffle()` を使用します．乱数生成用の関数オブジェクトは指定しないため，必要であれば `std::srand()` による初期化をおこなってください．
